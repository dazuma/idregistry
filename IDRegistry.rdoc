= IDRegistry

IDRegistry is a generic object generator and identity map for Ruby.

This document provides an in-depth introduction to using IDRegistry. For a quick introduction, see the README.

== Identity Maps and Registries

IDRegistry combines two patterns from Martin Fowler's book "Patterns of Enterprise Application Architecture": the Identity Map pattern and the Registry pattern.

An Identity Map is essentially an in-memory cache that references objects based on a unique identifier. Whenever you want to obtain an object, you first check the cache to see if the object already exists---technically, if the cache contains an object for the given unique identifier. If so, you pull that existing instance directly from the cache. Otherwise, you construct the object, making any necessary database calls, and then insert it into the cache. It has now effectively been memoized, and the next time you request that identifier, that same instance will be returned again from the cache.

In addition to the performance benefits of a cache, an Identity Map also ensures that at most one copy of any object will exist in your system at any time. This effectively eliminates a whole class of bugs that could arise if you construct multiple copies of an object whose states get out of sync with each other.

Identity Map is a highly useful pattern, but by itself it tends to be cumbersome to implement. This is because you have to find every point in the code that constructs a model object, and inject some code to manage the cache. To solve this, we combine it with the Registry pattern. A Registry is simply a central source for object procurement; any code that wants to obtain a model object must get it from the Registry. The Registry knows how to construct the object if needed. Thus, it is able to encapsulate the Identity Map logic, providing a one-stop solution for object procurement with caching and duplication elimination. This combination is what we call an IDRegistry.

== Tuples and Patterns

A common practice is to use database primary keys as the unique identifiers for an Identity Map. However, if you are managing multiple kinds of objects, objects that span multiple tables or aren't associated with any particular database row, or objects that otherwise need to be identified across more than one dimension, you need a more versatile unique identifier.

IDRegistry uses arrays, or <i>tuples</i> as we will call them, as unique identifiers. This allows us to support a wide variety of identification strategies. A simple example is to employ a two-element tuple: the first element being a type indicator, and the second being a database primary key. For example, suppose your application had two types of entities: users and blog posts. Your user objects could employ unique identifiers of the form <tt>[:user, <i>user-id</i>]</tt>, and your post objects could employ identifiers of the form <tt>[:post, <i>post-id</i>]</tt>. So the tuple <tt>[:user, 1]</tt> identifies the user with ID 1, and the tuple <tt>[:post, 210]</tt> identifies the post with ID 210.

Such "forms" of tuples that correspond to "types" of objects, we denote as <i>patterns</i>. A pattern is an array like a tuple, but some of its elements are types rather than values. For example, <tt>[:user, 1]</tt> is a tuple that identifies the particular user with ID 1, while <tt>[:user, Integer]</tt> is the pattern followed by user identifiers. Similarly, <tt>[:post, Integer]</tt> is the pattern followed by blog post identifiers.

Technically, in IDRegistry, a "type" element in a pattern can be any object that responds appropriately to the === operator. In most cases, these will be class or module objects (such as <tt>Integer</tt> above). However, patterns can utilize regular expressions, or any other object that classifies based on the === operator.

Tuples (and patterns) can be longer and more complex than the two-element examples above. Here are a few more examples.

Suppose you have a tree of node objects, each uniquely identified by a parent node and a child name. You might structure your identifiers according to the pattern <tt>[:tree, TreeNode, String]</tt>.

Suppose you have objects that represent relationships between users in a social network. Each relationship would be identified by the user IDs of the two users involved. You might structure your identifiers according to the pattern <tt>[:relationship, Integer, Integer]</tt>. For this case, you might need to decide whether <tt>[:relationship, 1, 2]</tt> and <tt>[:relationship, 2, 1]</tt> should refer to the same or different objects in your application. If they should refer to the same object, you should pre-filter your tuples so that, for example, the first user ID is always the smaller.

== Basic IDRegistry usage

Creating an IDRegistry is as simple as calling the <tt>create</tt> method:

 my_registry = IDRegistry.create

The job of an IDRegistry is to procure objects by either returning a cached object or creating a new one. Thus, it needs to know how to construct your model objects. You accomplish this by configuring the registry at application initialization time, telling it how to construct the various types of objects it needs to manage.

In the previous section, we saw how a "type" of object can be identified with a <i>pattern</i>. Through configuration, we "teach" an IDRegistry how to construct objects for a given pattern. For example, our user objects have identifiers matching the pattern <tt>[:user, Integer]</tt>. We can configure a registry as follows:

 my_registry.config.add_pattern |pattern|
   pattern.pattern [:user, Integer]
   pattern.to_generate_object do |tuple|
     my_create_user_object_given_id(tuple[1])
   end
 end

The <tt>add_pattern</tt> configuration command teaches the IDRegistry about a certain pattern. If the registry encounters a tuple identifier matching that pattern, it specifies how to construct the object given that tuple.

You can add any number of pattern configurations to a registry, covering any number of object types.

Once you have configured your IDRegistry, using it is simple. Call the <tt>lookup</tt> method to obtain an object given a tuple. The registry will check its cache and return the object, or it will invoke the matching pattern configuration to create it.

 user1 = my_registry.lookup(:user, 1)   # constructs a user object
 user1a = my_registry.lookup(:user, 1)  # returns the same user object

If you want to clear the cache and force the registry to construct new objects, use the <tt>clear</tt> method:

 my_registry.clear

== Multiple identifiers for an object

Sometimes there will be several different mechanisms for identifying an object to procure. Consider a tree stored in the database. Each node might have a database primary key, so you could identify objects using the pattern <tt>[:node, Integer]</tt>. However, you might also want to navigate from parent to child by child name, using a pattern such as <tt>[:node, Integer, String]</tt> similar to the tree example we covered earlier. That is, conceptually, we might want to have these two ways of obtaining an object in the tree:

 object = find_tree_node_id(id)
 object = find_tree_from_parent_id_and_child_name(parent_id, child_name)

These two ways to lookup the object correspond to two different tuples---two different unique identifiers. In a simple Identity Map, this would not work. It might create an object using the first identifier, and then create a second object using the second identifier, even if semantically they should be the same object.

IDRegistry, however, supports this case by giving you the ability to connect multiple patterns and associate them with the same object type. Here's how.

 my_registry.config do |config|
   config.add_pattern do |pattern|
     pattern.type :tree
     pattern.pattern [:tree, Integer]
     pattern.to_generate_object do |tuple|
       find_tree_node_id(tuple[1])
     end
     pattern.to_generate_tuple do |obj|
       [:user, obj.id]
     end
   end
   config.add_pattern do |pattern|
     pattern.type :tree
     pattern.pattern [:tree, Integer, String]
     pattern.to_generate_object do |tuple|
       find_tree_from_parent_id_and_child_name(tuple[1], tuple[2])
     end
     pattern.to_generate_tuple do |obj|
       [:user, obj.parent_id, obj.name]
     end
   end
 end

Let's unpack this. First, notice that we are now specifying a "type" for each pattern. The type is a name for this type of object. If you omit it (as we did earlier), IDRegistry automatically generates a new anonymous type for each pattern that you add. In this case, however, we set it explicitly. This lets us specify that both patterns describe the same type of object, a tree node object. Each tree node will now have TWO identifiers, one of each pattern. So doing a lookup for either identifiers will return the same object.

Second, now in addition to the <tt>to_generate_object</tt> block, we now provide a <tt>to_generate_tuple</tt> block. We need to tell IDRegistry how to generate a tuple (identifier) from an object. Why?

Well, suppose were were to look up a tree node by ID:

 node = my_registry.lookup(:tree, 10)

At this point, IDRegistry can cache the object and associate it with the tuple <tt>[:tree, 1]</tt> so that you can look it up using that tuple again. It also knows that the object can have a tuple with the pattern <tt>[:tree, Integer, String]</tt>, but it doesn't know what that tuple actually is. It needs for you to provide a way to generate that other tuple. Similarly, if you originally looked up the tree node by parent ID and name, IDRegistry needs you to teach it how to generate the corresponding simple ID tuple.

 # Returns the same object as the original node
 node1 = my_registry.lookup(:tree, node.parent_id, node.name)

So to summarize... if you have only one way to look up an object, you can simply specify the pattern and a <tt>to_generate_object</tt> block. For objects that can be looked up in more than one way, you should also include a type, to connect the various patterns together, and a <tt>to_generate_tuple</tt> block, which tells IDRegistry how to generate missing tuples.

== Web requests

In a web application, you will typically want to "scope" an identity map to a request. That is, you usually won't want objects from one request leaking into the next. IDRegistry provides two different mechanisms to limit the scope of a registry.

First, if you are certain that only one request will be run at a time in any given process, you can keep a single global registry, and just clean it out at the end of a request. IDRegistry provides a Rack middleware for this purpose. If you are running Rails, you can include a Railtie that installs the middleware for you, and gives you a configuration that you can use to specify which registry to clear.

If you are running multithreaded, then you will need multiple registries, one for each request. The easiest way to do this is to configure a registry as a "template" at startup, and then use the spawn_registry method to create a new empty registry from that template for each request. A Rack middleware that implements this strategy is also provided.

== Thread safety

IDRegistry is fully thread safe. All the configuration and object lookup and manipulation methods, are always re-entrant and can be called concurrently from multiple threads. Access to critical sections will be serialized internally.

There is, however, one caveat that has to do with the callbacks for constructing objects or generating tuples. IDRegistry does not include callbacks within a critical section. This means it is possible, in a multi-threaded environment, for a callback to be called but its result to be discarded. Here is the scenario:

* Two threads simultaneously call Registry#lookup for the same tuple that is not already present in the identity map.
* Both threads check for the tuple and determine that it is not present.
* Both threads then call the callback to create the object. Both object creations happen concurrently. Two objects have now been created. IDRegistry does not put any mutual exclusion on object creation.
* However, only one of the two objects will actually be used. Whichever thread actually finishes creating the object first, will be able to store that object in the identity map and return that object. The other slower thread will throw away the object it created, and instead return the object that the first thread created.

Therefore, our desired behavior still holds. Only one copy of the object actually ends up used in the system. However, it is possible, in a multi-threaded environment, for IDRegistry to ask for an object to be created but not actually use it.

== Categories

(...to be written...)

== Convenience methods

(...to be written...)
